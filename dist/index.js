!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.toru=e():t.toru=e()}(self,(function(){return(()=>{"use strict";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Actor:()=>T,Attachment:()=>D,BasicCamera:()=>P,Component:()=>y,Cube:()=>Q,CubeSphere:()=>et,CubeSphereFace:()=>nt,Geometry:()=>x,Light:()=>V,LightComponent:()=>G,Material:()=>M,MaterialShader:()=>B,Matrix4:()=>n,Mesh:()=>b,Obj:()=>X,OrbitCamera:()=>C,Quad:()=>ot,RenderTexture:()=>I,Renderer:()=>E,ScaleFilter:()=>R,Scene:()=>z,Shader:()=>A,SimpleShader:()=>H,Sphere:()=>tt,SphereMaterialShader:()=>k,SpriteShader:()=>j,StaticMesh:()=>L,Texture:()=>F,WebGLRenderer:()=>U,addVector3:()=>l,addVector4:()=>o,cross:()=>d,distanceVector3:()=>h,dot:()=>m,lonLatToPoint:()=>w,magnitude:()=>p,multiplyVector3:()=>c,multiplyVector4:()=>s,normalize:()=>f,pointToLonLat:()=>g,raySphereIntersection:()=>v,scaleVector3:()=>a,scaleVector4:()=>i,subtractVector3:()=>u,subtractVector4:()=>r});class n{constructor(t){if(this._data=new Float32Array(16),t)for(let e=0;e<16;e++)this._data[e]=t[e]}static identity(){return new n([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}static fromColumns(t){return new n([t[0][0],t[1][0],t[2][0],t[3][0],t[0][1],t[1][1],t[2][1],t[3][1],t[0][2],t[1][2],t[2][2],t[3][2],t[0][3],t[1][3],t[2][3],t[3][3]])}static perspective(t,e,i,o){const r=e*(Math.PI/180),s=1/Math.tan(r/2),a=1/(i-o);return new n([s/t,0,0,0,0,s,0,0,0,0,(i+o)*a,i*o*a*2,0,0,-1,0])}static rotation(t,e,i){const o=[t,e,i];function r(t){return[Math.cos(o[t]),Math.sin(o[t])]}const[s,a]=r(0),[l,u]=r(1),[c,h]=r(2),d=new n([1,0,0,0,0,s,-a,0,0,a,s,0,0,0,0,1]),m=new n([l,0,u,0,0,1,0,0,-u,0,l,0,0,0,0,1]),f=new n([c,-h,0,0,h,c,0,0,0,0,1,0,0,0,0,1]);return d.multiply(m.multiply(f))}static translation(t,e,i){return new n([1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1])}static scaling(t,e,i){return null==e&&(e=t),null==i&&(i=e),new n([t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1])}static lookAt(t,e){const i=f([t[0]-e[0],t[1]-e[1],t[2]-e[2]]),o=d([0,1,0],i),r=d(i,o);return new n([o[0],r[0],i[0],t[0],o[1],r[1],i[1],t[1],o[2],r[2],i[2],t[2],0,0,0,1])}clone(){return new n(this._data)}toArray(){return Array.from(this._data)}at(t,e){const n=4*e+t;return this._data[n]}column(t){const e=this._data;return[e[t+0],e[t+4],e[t+8],e[t+12]]}row(t){const e=this._data,n=4*t;return[e[n+0],e[n+1],e[n+2],e[n+3]]}get columns(){return[this.column(0),this.column(1),this.column(2),this.column(3)]}get rows(){return[this.row(0),this.row(1),this.row(2),this.row(3)]}multiply(t){const[e,i,o,r]=t.columns,s=[this.multiplyVector4(e),this.multiplyVector4(i),this.multiplyVector4(o),this.multiplyVector4(r)];return n.fromColumns(s)}multiplyVector4(t){const e=this.columns,n=i(e[0],t[0]),o=i(e[1],t[1]),r=i(e[2],t[2]),s=i(e[3],t[3]);return[n[0]+o[0]+r[0]+s[0],n[1]+o[1]+r[1]+s[1],n[2]+o[2]+r[2]+s[2],n[3]+o[3]+r[3]+s[3]]}transformPoint3(t){const e=this.multiplyVector4([t[0],t[1],t[2],1]);return[e[0]/e[3],e[1]/e[3],e[2]/e[3]]}inverse(){const t=new Array(16),e=this.toArray();return t[0]=e[5]*e[10]*e[15]-e[5]*e[14]*e[11]-e[6]*e[9]*e[15]+e[6]*e[13]*e[11]+e[7]*e[9]*e[14]-e[7]*e[13]*e[10],t[1]=-e[1]*e[10]*e[15]+e[1]*e[14]*e[11]+e[2]*e[9]*e[15]-e[2]*e[13]*e[11]-e[3]*e[9]*e[14]+e[3]*e[13]*e[10],t[2]=e[1]*e[6]*e[15]-e[1]*e[14]*e[7]-e[2]*e[5]*e[15]+e[2]*e[13]*e[7]+e[3]*e[5]*e[14]-e[3]*e[13]*e[6],t[3]=-e[1]*e[6]*e[11]+e[1]*e[10]*e[7]+e[2]*e[5]*e[11]-e[2]*e[9]*e[7]-e[3]*e[5]*e[10]+e[3]*e[9]*e[6],t[4]=-e[4]*e[10]*e[15]+e[4]*e[14]*e[11]+e[6]*e[8]*e[15]-e[6]*e[12]*e[11]-e[7]*e[8]*e[14]+e[7]*e[12]*e[10],t[5]=e[0]*e[10]*e[15]-e[0]*e[14]*e[11]-e[2]*e[8]*e[15]+e[2]*e[12]*e[11]+e[3]*e[8]*e[14]-e[3]*e[12]*e[10],t[6]=-e[0]*e[6]*e[15]+e[0]*e[14]*e[7]+e[2]*e[4]*e[15]-e[2]*e[12]*e[7]-e[3]*e[4]*e[14]+e[3]*e[12]*e[6],t[7]=e[0]*e[6]*e[11]-e[0]*e[10]*e[7]-e[2]*e[4]*e[11]+e[2]*e[8]*e[7]+e[3]*e[4]*e[10]-e[3]*e[8]*e[6],t[8]=e[4]*e[9]*e[15]-e[4]*e[13]*e[11]-e[5]*e[8]*e[15]+e[5]*e[12]*e[11]+e[7]*e[8]*e[13]-e[7]*e[12]*e[9],t[9]=-e[0]*e[9]*e[15]+e[0]*e[13]*e[11]+e[1]*e[8]*e[15]-e[1]*e[12]*e[11]-e[3]*e[8]*e[13]+e[3]*e[12]*e[9],t[10]=e[0]*e[5]*e[15]-e[0]*e[13]*e[7]-e[1]*e[4]*e[15]+e[1]*e[12]*e[7]+e[3]*e[4]*e[13]-e[3]*e[12]*e[5],t[11]=-e[0]*e[5]*e[11]+e[0]*e[9]*e[7]+e[1]*e[4]*e[11]-e[1]*e[8]*e[7]-e[3]*e[4]*e[9]+e[3]*e[8]*e[5],t[12]=-e[4]*e[9]*e[14]+e[4]*e[13]*e[10]+e[5]*e[8]*e[14]-e[5]*e[12]*e[10]-e[6]*e[8]*e[13]+e[6]*e[12]*e[9],t[13]=e[0]*e[9]*e[14]-e[0]*e[13]*e[10]-e[1]*e[8]*e[14]+e[1]*e[12]*e[10]+e[2]*e[8]*e[13]-e[2]*e[12]*e[9],t[14]=-e[0]*e[5]*e[14]+e[0]*e[13]*e[6]+e[1]*e[4]*e[14]-e[1]*e[12]*e[6]-e[2]*e[4]*e[13]+e[2]*e[12]*e[5],t[15]=e[0]*e[5]*e[10]-e[0]*e[9]*e[6]-e[1]*e[4]*e[10]+e[1]*e[8]*e[6]+e[2]*e[4]*e[9]-e[2]*e[8]*e[5],0==e[0]*t[0]+e[4]*t[4]+e[8]*t[8]+e[12]*t[12]?null:new n(t)}extractTranslation(){const t=this._data[3],e=this._data[7],i=this._data[11];return n.translation(t,e,i)}extractScaling(){return n.scaling(0,0,0)}extractRotation(){return n.rotation(0,0,0)}eulerAngles(){const t=Math.sqrt(this.at(0,0)*this.at(0,0)+this.at(1,0)*this.at(1,0));let e=0,n=0,i=0;return t<1e-6?(e=Math.atan2(this.at(1,2),this.at(1,1)),n=Math.atan2(this.at(2,0),t),i=0):(e=Math.atan2(-this.at(2,1),this.at(2,2)),n=Math.atan2(this.at(2,0),t),i=Math.atan2(-this.at(1,0),this.at(0,0))),[e,n,i]}}function i(t,e){return[t[0]*e,t[1]*e,t[2]*e,t[3]*e]}function o(t,e){return[t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3]]}function r(t,e){return[t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3]]}function s(t,e){return[t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3]]}function a(t,e){return[t[0]*e,t[1]*e,t[2]*e]}function l(t,e){return[t[0]+e[0],t[1]+e[1],t[2]+e[2]]}function u(t,e){return[t[0]-e[0],t[1]-e[1],t[2]-e[2]]}function c(t,e){return[t[0]*e[0],t[1]*e[1],t[2]*e[2]]}function h(t,e){const n=u(t,e);return Math.abs(p(n))}function d(t,e){return[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]]}function m(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function f(t){const e=p(t);return[t[0]/e,t[1]/e,t[2]/e]}function p(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}function v(t,e,n,i){const o=[n[0]-t[0],n[1]-t[1],n[2]-t[2]],r=Math.pow(p(i),2),s=m(i,o),a=s*s-r*(Math.pow(p(o),2)-e*e);if(a<0)return null;const l=Math.sqrt(a),u=(-s-l)/r,c=(-s+l)/r;if(c<0)return null;const h=u>=0?u:c;return[n[0]+h*i[0],n[1]+h*i[1],n[2]+h*i[2]]}function g(t){const e=f(t),n=f([e[0],0,e[2]]);let i=Math.acos(m(n,e));e[1]<0&&(i*=-1);let o=-Math.atan2(-e[2],-e[0])-Math.PI/2;return o<-Math.PI&&(o+=2*Math.PI),[o,i]}function w(t,e=1){const n=t[0]-Math.PI,i=t[1]-Math.PI/2;return[e*Math.sin(i)*Math.sin(n),e*Math.cos(i),e*Math.sin(i)*Math.cos(n)]}class x{constructor(t,e){this.vertices=[],this.transform=n.identity(),t&&(this.vertices=[...t]),(null==e?void 0:e.transform)&&(this.transform=e.transform)}clone(){return new x(this.vertices.map((t=>Object.assign({},t))),{transform:this.transform.clone()})}calculateNormals(){if(0===this.vertices.length)return;const t=this.vertices;if(!("normal"in t[0]))throw"Geometry Vertex doesn't have a 'normal' attribute";for(let e=0;e<this.vertices.length;e+=3){const n=t[e+0].position,i=t[e+1].position,o=t[e+2].position,r=f(d([i[0]-n[0],i[1]-n[1],i[2]-n[2]],[o[0]-n[0],o[1]-n[1],o[2]-n[2]]));t[e+0].normal=r,t[e+1].normal=r,t[e+2].normal=r}}}class b{constructor(t){this.doubleSided=!1,this.geometries=[],t&&(Array.isArray(t)?0===t.length||t[0]instanceof x?this.geometries=[...t]:this.geometries=[new x(t)]:this.geometries=[t])}clone(){return new b(this.geometries.map((t=>t.clone())))}get vertexCount(){let t=0;for(const e of this.geometries)t+=e.vertices.length;return t}get vertices(){const t=new Array(this.vertexCount);let e=0;for(const n of this.geometries)for(const i of n.vertices)t[e]=Object.assign(Object.assign({},i),{position:n.transform.transformPoint3(i.position)}),e++;return t}calculateNormals(){for(const t of this.geometries)t.calculateNormals()}}class M{constructor(t){this.color=[1,0,0,0],this.texture=null,this.normalMap=null,this.specularMap=null,this.displacementMap=null,this.displacementMultiplier=1,this.receivesShadows=!0,this.castsShadows=!0,this.emissive=!1,this.wireframe=!1,null!=(null==t?void 0:t.color)&&(this.color=t.color),null!=(null==t?void 0:t.texture)&&(this.texture=t.texture),null!=(null==t?void 0:t.normalMap)&&(this.normalMap=t.normalMap),null!=(null==t?void 0:t.specularMap)&&(this.specularMap=t.specularMap),null!=(null==t?void 0:t.displacementMap)&&(this.displacementMap=t.displacementMap),null!=(null==t?void 0:t.displacementMultiplier)&&(this.displacementMultiplier=t.displacementMultiplier),null!=(null==t?void 0:t.receivesShadows)&&(this.receivesShadows=t.receivesShadows),null!=(null==t?void 0:t.castsShadows)&&(this.castsShadows=t.castsShadows),null!=(null==t?void 0:t.emissive)&&(this.emissive=t.emissive),null!=(null==t?void 0:t.wireframe)&&(this.wireframe=t.wireframe)}}class y{}class L extends y{constructor(t){super(),this.mesh=t}}class T{constructor(t,e={}){this.visible=!0,this.components=[],this.model=n.identity(),this.uniforms={},this.children=[],this.instances=new Map,this.nextInstanceId=1,t instanceof Array?this.children=t:t instanceof b?this.components.push(new L(t)):"object"==typeof t&&(e=t);const i=e.material||new M;i.color=e.color||i.color,this.material=i,e.model&&(this.model=e.model),e.shader&&(this.shader=e.shader),e.uniforms&&(this.uniforms=Object.assign(Object.assign({},this.uniforms),e.uniforms)),e.components&&(this.components=[...this.components,...e.components])}instance(t){const e=this.nextInstanceId++,n={id:e,pawn:this,data:Object.assign({},t)};return this.instances.set(e,n),e}get hasInstances(){return 0!==this.instances.size}get translationMatrix(){return this.model.extractTranslation()}get rotationMatrix(){return this.model.extractRotation()}get position(){return this.model.transformPoint3([0,0,0])}set position(t){const e=this.model.toArray();e[3]=t[0],e[7]=t[1],e[11]=t[2],this.model=new n(e)}get rotationVector(){const t=this.model.multiplyVector4([0,0,1,0]);return[t[0],t[1],t[2]]}getComponentsOfType(t){return this.components.filter((e=>e instanceof t))}hasComponentOfType(t){return Boolean(this.components.find((e=>e instanceof t)))}}class C extends T{constructor(){super(),this.near=.1,this.far=1e3,this.distance=10,this.target=[0,0,0],this.rotation={lon:0,lat:0},this.resize(1024,768)}get view(){const t=this.target;return n.identity().multiply(n.translation(t[0],t[1],t[2])).multiply(n.rotation(0,this.rotation.lon,0)).multiply(n.rotation(this.rotation.lat,0,0)).multiply(n.translation(0,0,this.distance))}resize(t,e){this.width=t,this.height=e,this.projection=n.perspective(t/e,45,this.near,this.far)}zoom(t){this.distance+=t}rotate(t,e){this.rotation={lon:this.rotation.lon+t,lat:this.rotation.lat+e},this.rotation.lat<-Math.PI/2&&(this.rotation.lat=-Math.PI/2),this.rotation.lat>Math.PI/2&&(this.rotation.lat=Math.PI/2)}}class P extends T{constructor(){super(),this.near=1,this.far=2e3,this.position=[0,1,0],this.rotation=[0,0,0],this.scaling=[1,1,1],this.resize(1024,768)}get view(){return n.identity().multiply(n.translation(...this.position)).multiply(this.rotationMatrix).multiply(n.scaling(...this.scaling))}get rotationMatrix(){return n.identity().multiply(n.rotation(0,0,this.rotation[2])).multiply(n.rotation(0,this.rotation[1],0)).multiply(n.rotation(this.rotation[0],0,0))}updateModel(){this.model=this.view}rotate(t,e){this.rotation[0]-=Math.PI*t,this.rotation[1]-=Math.PI*e,this.rotation[0]<-Math.PI/2+.01&&(this.rotation[0]=-Math.PI/2+.01),this.rotation[0]>Math.PI/2-.01&&(this.rotation[0]=Math.PI/2-.01),this.updateModel()}translate(t,e,i){const o=n.translation(t,e,i),r=this.rotationVector,s=r[0];r[0]=0;const a=this.rotationMatrix;r[0]=s;const l=a.inverse();let u=o.multiply(l).transformPoint3(this.position);u=a.transformPoint3(u),this.position=u,this.updateModel()}resize(t,e){this.width=t,this.height=e,this.projection=n.perspective(t/e,45,this.near,this.far),this.updateModel()}}class E{constructor(){this.camera=new P,this.mousePosition=[0,0],this.mouseMovement=[0,0],this.wheelMovement=[0,0],this.mouseButtons=new Set,this.heldKeys=new Set,this.backgroundColor=[0,0,0,1]}updateSize(t,e){}resetMouseMovement(){this.mouseMovement[0]=0,this.mouseMovement[1]=0,this.wheelMovement[0]=0,this.wheelMovement[1]=0}addEventListener(t,e,n){}removeEventListener(t,e,n){}get isDragging(){return!1}}class A{constructor(t,e,n,i){this.compiled=!1,this.attributes={position:{type:WebGLRenderingContext.FLOAT,size:3,location:null}},this.instanceAttributes={},this.uniforms={uTime:{type:WebGLRenderingContext.FLOAT,location:null},uViewProj:{type:WebGLRenderingContext.FLOAT_MAT4,location:null},uView:{type:WebGLRenderingContext.FLOAT_MAT4,location:null},uModel:{type:WebGLRenderingContext.FLOAT_MAT4,location:null},uFillColor:{type:WebGLRenderingContext.FLOAT_VEC4,location:null},uFogColor:{type:WebGLRenderingContext.FLOAT_VEC4,location:null},uLineWidth:{type:WebGLRenderingContext.FLOAT,location:null},uResolution:{type:WebGLRenderingContext.FLOAT_VEC2,location:null},uSeed:{type:WebGLRenderingContext.FLOAT,location:null}},t&&this.make(t,e,n,i)}make(t,e,n,i){if(this.gl=t,!e)throw"You must provide vertex shader source code";if(!n)throw"You must provide fragment shader source code";const o=t.createProgram();(null==i?void 0:i.attributes)&&(this.attributes=Object.assign(Object.assign({},this.attributes),i.attributes)),(null==i?void 0:i.instanceAttributes)&&(this.instanceAttributes=Object.assign(Object.assign({},this.instanceAttributes),i.instanceAttributes)),(null==i?void 0:i.uniforms)&&(this.uniforms=Object.assign(Object.assign({},this.uniforms),i.uniforms)),t.getExtension("OES_standard_derivatives");const r=t.createShader(t.VERTEX_SHADER);if(t.shaderSource(r,e),t.attachShader(o,r),t.compileShader(r),!t.getShaderParameter(r,t.COMPILE_STATUS))throw`Could not compile Vertex shader: ${t.getShaderInfoLog(r)}`;const s=t.createShader(t.FRAGMENT_SHADER);if(t.shaderSource(s,n),t.attachShader(o,s),t.compileShader(s),!t.getShaderParameter(s,t.COMPILE_STATUS))throw`Could not compile Fragment shader: ${t.getShaderInfoLog(s)}`;if(t.linkProgram(o),!t.getProgramParameter(o,t.LINK_STATUS)){const e=t.getProgramInfoLog(o);throw`Could not link WebGL program (${this.constructor.name}): ${e}`}for(const e in this.uniforms)this.uniforms[e].location=t.getUniformLocation(o,e);for(const e in this.attributes)this.attributes[e].location=t.getAttribLocation(o,e);for(const e in this.instanceAttributes)this.instanceAttributes[e].location=t.getAttribLocation(o,e);t.enable(t.CULL_FACE),t.cullFace(t.BACK),this.program=o,this.compiled=!0}use(){this.gl.useProgram(this.program)}bind(t){const e=this.gl;e.bindBuffer(e.ARRAY_BUFFER,t.buffer);const n=e.getExtension("ANGLE_instanced_arrays");for(const i in this.attributes){const o=this.attributes[i];if(null==o.location||-1===o.location)continue;n.vertexAttribDivisorANGLE(o.location,0);const r=t.stride,s=t.offsets.get(i);null!=s?(e.enableVertexAttribArray(o.location),e.vertexAttribPointer(o.location,o.size,o.type,!1,r,s)):e.disableVertexAttribArray(o.location)}}unbind(){const t=this.gl;for(const e in this.attributes){const n=this.attributes[e];null!=n.location&&-1!==n.location&&t.disableVertexAttribArray(n.location)}}bindInstances(t,e){const n=t.getExtension("ANGLE_instanced_arrays");t.bindBuffer(t.ARRAY_BUFFER,e.instanceBuffer);for(const i in this.instanceAttributes){const o=this.instanceAttributes[i];if(null==o.location||-1===o.location)continue;const r=e.instanceStride;let s=e.instanceOffsets.get(i);if(null==s)throw`Unable to find instanceOffset for ${i}`;if(16===o.size)for(let e=0;e<4;e++){const i=o.location+e;t.enableVertexAttribArray(i),t.vertexAttribPointer(i,4,o.type,!1,r,s),n.vertexAttribDivisorANGLE(i,1),s+=16}else t.enableVertexAttribArray(o.location),t.vertexAttribPointer(o.location,o.size,o.type,!1,r,s),n.vertexAttribDivisorANGLE(o.location,1)}}unbindInstances(t){const e=t.getExtension("ANGLE_instanced_arrays");for(const n in this.instanceAttributes){const i=this.instanceAttributes[n];if(null!=i.location&&-1!==i.location&&16===i.size)for(let n=0;n<4;n++){const o=i.location+n;t.disableVertexAttribArray(o),e.vertexAttribDivisorANGLE(o,0)}}}setUniform(t,e){if(null==e)return;const i=this.gl,o=this.uniforms[t];if(o)switch(o.type){case WebGLRenderingContext.BOOL:if("boolean"!=typeof e)throw`Uniform '${t}' expected boolean but got: ${typeof e}`;i.uniform1i(o.location,e?1:0);break;case WebGLRenderingContext.FLOAT:if("number"==typeof e)i.uniform1f(o.location,e);else{if(!Array.isArray(e)||"number"!=typeof e[0])throw`Uniform '${t}' expected number but got: ${typeof e}`;i.uniform1fv(o.location,e)}break;case WebGLRenderingContext.INT:if("number"==typeof e)i.uniform1i(o.location,e);else{if(!Array.isArray(e)||"number"!=typeof e[0])throw`Uniform '${t}' expected number but got: ${typeof e}`;i.uniform1iv(o.location,e)}break;case WebGLRenderingContext.FLOAT_VEC2:if(!Array.isArray(e)||2!==e.length||"number"!=typeof e[0]||"number"!=typeof e[1])throw`Uniform '${t}' expected an array of 2 numbers but got something else`;i.uniform2fv(o.location,e);break;case WebGLRenderingContext.FLOAT_VEC3:if(!Array.isArray(e)||3!==e.length||"number"!=typeof e[0]||"number"!=typeof e[1]||"number"!=typeof e[2])throw`Uniform '${t}' expected an array of 3 numbers but got something else`;i.uniform3fv(o.location,e);break;case WebGLRenderingContext.FLOAT_VEC4:if(!Array.isArray(e)||4!==e.length||"number"!=typeof e[0]||"number"!=typeof e[1]||"number"!=typeof e[2]||"number"!=typeof e[3])throw`Uniform '${t}' expected an array of 4 numbers but got something else`;i.uniform4fv(o.location,e);break;case WebGLRenderingContext.FLOAT_MAT4:if(!(e instanceof n))throw`Uniform '${t}' expected a Matrix4 but got something else`;i.uniformMatrix4fv(o.location,!1,e.toArray());break;default:throw`Unsupported uniform type: ${o.type}`}}}class S{constructor(t){this.offsets=new Map,this.instanceOffsets=new Map,this.doubleSided=!1,this.gl=t}upload(t){const e=this.gl;this.buffer||(this.buffer=e.createBuffer());const n=t.vertices;if(this.length=n.length,0===n.length)return;const i=Object.keys(n[0]).sort();let o=0;for(const t of i){const e=n[0][t];this.offsets.set(t,4*o),Array.isArray(e)?o+=e.length:o+=1}this.stride=4*o;let r=0;const s=new Float32Array(n.length*o);for(const t of n)for(const e of i){const n=t[e];if(Array.isArray(n))for(const t of n)s[r]=t,r++;else s[r]=n,r++}this.bind(),e.bufferData(e.ARRAY_BUFFER,s,e.DYNAMIC_DRAW),this.doubleSided=t.doubleSided}uploadInstances(t){if(0===t.length)return;const e=this.gl,i=Object.keys(t[0]).sort();let o=0;for(const e of i){const i=t[0][e];this.instanceOffsets.set(e,4*o),Array.isArray(i)?o+=i.length:o+=i instanceof n?i.toArray().length:1}this.instanceStride=4*o;let r=0;const s=new Float32Array(t.length*o);for(const e of t)for(const t of i){const i=e[t];if(Array.isArray(i))for(const t of i)s[r]=t,r++;else if(i instanceof n)for(const t of i.toArray())s[r]=t,r++;else s[r]=i,r++}this.instanceBuffer||(this.instanceBuffer=e.createBuffer()),this.instanceLength=t.length,e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer),e.bufferData(e.ARRAY_BUFFER,s,e.DYNAMIC_DRAW)}bind(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer)}draw(){this.setFaceCulling(),this.gl.drawArrays(this.gl.TRIANGLES,0,this.length)}drawLines(){this.setFaceCulling(),this.gl.lineWidth(1),this.gl.drawArrays(this.gl.LINE_STRIP,0,this.length)}drawInstances(){this.setFaceCulling(),this.gl.getExtension("ANGLE_instanced_arrays").drawArraysInstancedANGLE(this.gl.TRIANGLES,0,this.length,this.instanceLength)}setFaceCulling(){this.doubleSided?this.gl.disable(this.gl.CULL_FACE):this.gl.enable(this.gl.CULL_FACE)}}var R,D;!function(t){t[t.LINEAR=0]="LINEAR",t[t.NEAREST=1]="NEAREST"}(R||(R={}));class F{constructor(t,e){if(this.minFilter=R.LINEAR,this.magFilter=R.LINEAR,this.putPixels(new ImageData(new Uint8ClampedArray([255,0,255,255]),1,1)),(null==e?void 0:e.minFilter)&&(this.minFilter=e.minFilter),(null==e?void 0:e.magFilter)&&(this.magFilter=e.magFilter),t)if("string"==typeof t){const e=new Image;e.src=t,this.putImage(e)}else t instanceof HTMLImageElement?this.putImage(t):this.putPixels(t)}static fromUrl(t,e){return n=this,i=void 0,r=function*(){return new Promise(((n,i)=>{const o=new Image;o.src=t,o.addEventListener("load",(()=>{n(new F(o,e))})),o.addEventListener("error",(t=>{i(t)}))}))},new((o=void 0)||(o=Promise))((function(t,e){function s(t){try{l(r.next(t))}catch(t){e(t)}}function a(t){try{l(r.throw(t))}catch(t){e(t)}}function l(e){var n;e.done?t(e.value):(n=e.value,n instanceof o?n:new o((function(t){t(n)}))).then(s,a)}l((r=r.apply(n,i||[])).next())}));var n,i,o,r}putImage(t){t.complete?this.putPixels(t):t.addEventListener("load",(()=>{this.putImage(t)}))}putPixels(t){if(t instanceof HTMLImageElement&&!t.complete)throw"Attempted to use incomplete image as texture";this.pixels=t}get data(){if(this.pixels instanceof ImageData)return this.pixels.data;throw"Can't get data of an HTMLImageElement"}get width(){return this.pixels.width}get height(){return this.pixels.height}}!function(t){t[t.COLOR=0]="COLOR",t[t.DEPTH=1]="DEPTH"}(D||(D={}));class I extends F{constructor(t,e=D.COLOR){super(),this.attachment=e,this.size=t;const n=new Uint8ClampedArray(t*t*4);n.fill(255),this.putPixels(new ImageData(n,t))}}const _={[R.LINEAR]:WebGLRenderingContext.LINEAR,[R.NEAREST]:WebGLRenderingContext.NEAREST};class O{constructor(t){this.level=0,this.internalFormat=WebGLRenderingContext.RGBA,this.srcFormat=WebGLRenderingContext.RGBA,this.srcType=WebGLRenderingContext.UNSIGNED_BYTE,this.minFilter=WebGLRenderingContext.LINEAR,this.magFilter=WebGLRenderingContext.LINEAR,this.gl=t,this.texture=t.createTexture()}static fromTexture(t,e){const n=new O(t);return n.minFilter=_[e.minFilter],n.magFilter=_[e.magFilter],e instanceof I&&e.attachment===D.DEPTH&&(n.internalFormat=t.DEPTH_COMPONENT,n.srcFormat=t.DEPTH_COMPONENT,n.srcType=t.UNSIGNED_INT,n.unusedColorTexture=t.createTexture()),n}upload(t,e=null){const n=t instanceof I?null:t.pixels;if(n instanceof HTMLImageElement&&!n.complete)throw"Attempted to use incomplete image as texture";this.unit=e;const i=this.gl;t instanceof I?(this.unusedColorTexture&&(i.activeTexture(i.TEXTURE0+this.unit),i.bindTexture(i.TEXTURE_2D,this.unusedColorTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,t.size,t.size,0,i.RGBA,i.UNSIGNED_BYTE,null),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,this.minFilter),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,this.magFilter)),this.bind(),i.texImage2D(i.TEXTURE_2D,this.level,this.internalFormat,t.size,t.size,0,this.srcFormat,this.srcType,null)):(this.bind(),i.texImage2D(i.TEXTURE_2D,this.level,this.internalFormat,this.srcFormat,this.srcType,n)),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,this.minFilter),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,this.magFilter)}bind(){if(null==this.unit)throw"Cannot bind texture that hasn't been uploaded";const t=this.gl;return t.activeTexture(t.TEXTURE0+this.unit),t.bindTexture(t.TEXTURE_2D,this.texture),this.unit}unbind(){if(null==this.unit)throw"Cannot unbind texture that hasn't been uploaded";const t=this.gl;t.activeTexture(t.TEXTURE0+this.unit),t.bindTexture(t.TEXTURE_2D,null)}}class N{constructor(t,e,n){this.attachment=WebGLRenderingContext.COLOR_ATTACHMENT0,this.gl=t,this.size=e,this.texture=n,this.framebuffer=t.createFramebuffer(),this.renderbuffer=t.createRenderbuffer()}bind(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,this.attachment,t.TEXTURE_2D,this.texture.texture,0),this.attachment==WebGLRenderingContext.DEPTH_ATTACHMENT?t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture.unusedColorTexture,0):(t.bindRenderbuffer(t.RENDERBUFFER,this.renderbuffer),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT16,this.size,this.size),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,this.renderbuffer))}unbind(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)}}class G extends y{constructor(t={}){super(),t.ambient&&(this.ambient=t.ambient),t.diffuse&&(this.diffuse=t.diffuse),t.specular&&(this.specular=t.specular),t.constant&&(this.constant=t.constant),t.linear&&(this.linear=t.linear),t.quadratic&&(this.quadratic=t.quadratic)}}const W=-1!==window.location.search.indexOf("debug");class U extends E{constructor(t){super(),this.scale=1*window.devicePixelRatio,this.lineWidth=2*window.devicePixelRatio,this.antiAlias=!0,this.vsync=!0,this.lastFrameAt=0,this.frameAverage=0,this.frame=0,this.isGrabbed=!1,this.seed=Math.random(),this.dragDelta=[0,0],this.textures=new Map,this.meshes=new Map,this.renderTargets=new Map,this.onPointerLockChange=()=>{this.isGrabbed||this.removeEventListeners()},this.onKeyDown=t=>{this.heldKeys.add(t.key.toLowerCase())},this.onKeyUp=t=>{this.heldKeys.delete(t.key.toLowerCase())},this.onMouseDown=t=>{this.dragDelta[0]=0,this.dragDelta[1]=0,this.mouseButtons.add(t.button)},this.onMouseUp=t=>{setTimeout((()=>{this.dragDelta[0]=0,this.dragDelta[1]=0}),1),this.mouseButtons.delete(t.button)},this.onMouseMove=t=>{this.mouseButtons.size>0&&(this.dragDelta[0]+=t.movementX,this.dragDelta[1]+=t.movementY),this.mousePosition[0]=t.clientX,this.mousePosition[1]=t.clientY,this.mouseMovement[0]+=t.movementX,this.mouseMovement[1]+=t.movementY},this.onWheel=t=>{if(!t.axis&&!t.wheelDelta)return;t.preventDefault();let e=0,n=0;if(!t.wheelDelta&&t.detail){const i=53*t.detail/3;t.axis===t.HORIZONTAL_AXIS?e=i:n=i}else e=t.deltaX,n=t.deltaY;this.wheelMovement[0]+=e,this.wheelMovement[1]+=n},t instanceof HTMLCanvasElement?this.canvas=t:(this.canvas=document.createElement("canvas"),t instanceof HTMLElement&&this.attach(t)),Object.assign(this.canvas.style,{position:"fixed",left:0,right:0,top:0,bottom:0})}get isDragging(){return Math.abs(this.dragDelta[0])>4||Math.abs(this.dragDelta[1])>4}get parentElement(){return this.canvas.parentElement}get gl(){if(this.context)return this.context;const t={antialias:this.antiAlias};if(this.context=this.canvas.getContext("webgl",t),!this.context)throw this.parentElement.innerHTML="Failed to create a WebGL context","Failed to create WebGL context";return this.context}get width(){return this.canvas.clientWidth}get height(){return this.canvas.clientHeight}initWebGL(){const t=this.gl;t.enable(t.DEPTH_TEST),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.defaultShader=this.createShader("#define GLSLIFY 1\nuniform mat4 uViewProj;\nuniform mat4 uModel;\nuniform vec4 uFogColor;\nuniform float uLineWidth;\n\nattribute vec3 position;\nattribute vec3 barycentric;\nattribute vec4 color;\n\nvarying vec4 vFogColor;\nvarying float vFogDepth;\nvarying vec3 vBarycentric;\nvarying float vLineWidth;\nvarying vec4 vColor;\n\nfloat fog_dist = 1000.0;\n\nvoid main(void) {\n\tmat4 mvp = uModel * uViewProj;\n\n\tgl_Position = vec4(position, 1.0) * mvp;\n\tvFogDepth = max(0.0, min(1.0, gl_Position.z / fog_dist));\n\tvFogColor = uFogColor;\n\tvLineWidth = uLineWidth;\n\n\tvColor = color;\n\tvBarycentric = barycentric;\n}\n","precision mediump float;\n\nvarying vec4 vFogColor;\nvarying float vFogDepth;\nvarying vec3 vBarycentric;\nvarying float vLineWidth;\nvarying vec4 vColor;\n\n#extension GL_OES_standard_derivatives : enable\n#define GLSLIFY 1\n\nfloat edgeDistance(vec3 barycentric) {\n\tvec3 d = fwidth(barycentric);\n\tvec3 a = smoothstep(vec3(0.0), d * 2.0, barycentric);\n\treturn min(min(a.x, a.y), a.z);\n}\n\nvoid main(void) {\n\tvec4 lineColor = vColor;\n\tvec4 faceColor = vec4(0.0, 0.0, 0.0, vColor.a);\n\tvec4 color;\n\tfloat d = edgeDistance(vBarycentric);\n\tif (d < 1.0) {\n\t\tcolor = mix(lineColor, faceColor, d);\n\t}\n\telse {\n\t\tcolor = faceColor;\n\t}\n\n\tgl_FragColor = mix(color, vFogColor, vFogDepth);\n}\n")}grab(t=!1){t&&this.canvas.requestPointerLock(),this.isGrabbed=!0,this.addEventListeners()}release(){this.isGrabbed=!1,document.exitPointerLock(),this.removeEventListeners()}addEventListeners(){document.addEventListener("pointerlockchange",this.onPointerLockChange),window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),window.addEventListener("mousemove",this.onMouseMove),window.addEventListener("mouseup",this.onMouseUp),window.addEventListener("mousedown",this.onMouseDown),window.addEventListener("wheel",this.onWheel,{passive:!1}),window.addEventListener("DOMMouseScroll",this.onWheel,{passive:!1})}removeEventListeners(){this.heldKeys.clear(),document.removeEventListener("pointerlockchange",this.onPointerLockChange),window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),window.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("wheel",this.onWheel),window.removeEventListener("DOMMouseScroll",this.onWheel)}clear(){const t=this.gl;t.clearDepth(1),t.clearColor(...this.backgroundColor),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT)}drawActorWithShader(t,e,n,i={}){var o;if(!e.visible)return;const{model:r,material:s,children:a}=e,{parentModel:l}=i,u=l?l.multiply(r):r;s&&(e.uniforms["uMaterial.color"]=3===s.color.length?[...s.color,1]:s.color,e.uniforms.uFillColor=e.uniforms["uMaterial.color"],e.uniforms["uMaterial.hasTexture"]=!!s.texture,e.uniforms["uMaterial.hasNormalMap"]=!!s.normalMap,e.uniforms["uMaterial.hasSpecularMap"]=!!s.specularMap,e.uniforms["uMaterial.hasDisplacementMap"]=!!s.displacementMap,e.uniforms["uMaterial.castsShadows"]=s.castsShadows,e.uniforms["uMaterial.receivesShadows"]=s.receivesShadows,e.uniforms["uMaterial.emissive"]=s.emissive,e.uniforms["uMaterial.displacementMultiplier"]=s.displacementMultiplier,s.texture&&(e.uniforms["uMaterial.texture"]=this.bindTexture(s.texture)),s.normalMap&&(e.uniforms["uMaterial.normalMap"]=this.bindTexture(s.normalMap)),s.specularMap&&(e.uniforms["uMaterial.specularMap"]=this.bindTexture(s.specularMap)),s.displacementMap&&(e.uniforms["uMaterial.displacementMap"]=this.bindTexture(s.displacementMap))),n&&t.setUniform("uViewProj",n),t.setUniform("uModel",u);for(const n in e.uniforms)t.setUniform(n,e.uniforms[n]);const c=null===(o=e.getComponentsOfType(L)[0])||void 0===o?void 0:o.mesh;if(c){let n=this.meshes.get(c);n||(this.uploadMesh(c),n=this.meshes.get(c)),t.bind(n),e.hasInstances?(t.bindInstances(this.gl,n),n.drawInstances()):s.wireframe?n.drawLines():n.draw()}for(const e of a)this.drawActorWithShader(t,e,n,Object.assign(Object.assign({},i),{parentModel:u}))}drawActor(t,e,n={}){var i;if(!t.visible)return;const{model:o,material:r,children:s}=t,{parentModel:a}=n,l=a?a.multiply(o):o;r&&(t.uniforms["uMaterial.color"]=3===r.color.length?[...r.color,1]:r.color,t.uniforms["uMaterial.hasTexture"]=!!r.texture,t.uniforms["uMaterial.hasNormalMap"]=!!r.normalMap,t.uniforms["uMaterial.hasSpecularMap"]=!!r.specularMap,t.uniforms["uMaterial.hasDisplacementMap"]=!!r.displacementMap,t.uniforms["uMaterial.castsShadows"]=r.castsShadows,t.uniforms["uMaterial.receivesShadows"]=r.receivesShadows,t.uniforms["uMaterial.emissive"]=r.emissive,t.uniforms["uMaterial.displacementMultiplier"]=r.displacementMultiplier,r.texture&&(t.uniforms["uMaterial.texture"]=this.bindTexture(r.texture)),r.normalMap&&(t.uniforms["uMaterial.normalMap"]=this.bindTexture(r.normalMap)),r.specularMap&&(t.uniforms["uMaterial.specularMap"]=this.bindTexture(r.specularMap)),r.displacementMap&&(t.uniforms["uMaterial.displacementMap"]=this.bindTexture(r.displacementMap)));const u=null===(i=t.getComponentsOfType(L)[0])||void 0===i?void 0:i.mesh;t.shader&&!t.shader.compiled&&t.shader.make(this.gl);const c=this.camera.view.inverse();if(u instanceof b){const i=this.gl,o=t.shader||this.defaultShader,s=o.uniforms;o.use();let a=this.meshes.get(u);if(a||(this.uploadMesh(u),a=this.meshes.get(u)),e&&i.uniformMatrix4fv(s.uViewProj.location,!1,e.toArray()),i.uniformMatrix4fv(s.uView.location,!1,c.toArray()),i.uniform4fv(s.uFogColor.location,this.backgroundColor),i.uniform1f(s.uLineWidth.location,this.lineWidth),i.uniform1f(s.uTime.location,performance.now()),i.uniform2fv(s.uResolution.location,[this.camera.width,this.camera.height]),i.uniform1f(s.uSeed.location,this.seed),i.uniformMatrix4fv(s.uModel.location,!1,l.toArray()),(null==r?void 0:r.color)&&i.uniform4fv(s.uFillColor.location,t.uniforms["uMaterial.color"]),null==n?void 0:n.uniforms)for(const t in n.uniforms)o.uniforms[t]&&o.setUniform(t,n.uniforms[t]);for(const e in t.uniforms)o.setUniform(e,t.uniforms[e]);o.bind(a),t.hasInstances?(o.bindInstances(i,a),a.drawInstances()):a.draw()}for(const t of s)this.drawActor(t,e,Object.assign(Object.assign({},n),{parentModel:l}))}uploadMesh(t){const e=this.gl;let n=this.meshes.get(t);n||(n=new S(e),this.meshes.set(t,n)),n.upload(t)}uploadMeshInstances(t,e){const n=this.gl;let i=this.meshes.get(t);i||(i=new S(n),this.meshes.set(t,i),i.upload(t)),i.uploadInstances(e)}removeMesh(t){if(this.meshes.get(t))throw"not yet implemented"}uploadTexture(t,e=null){const n=this.gl;let i=this.textures.get(t);return i||(i=O.fromTexture(n,t),this.textures.set(t,i)),null==e&&null==i.unit&&(e=this.textures.size-1),i.upload(t,null!=e?e:i.unit),e}bindTexture(t){let e=this.textures.get(t);return e||(this.uploadTexture(t),e=this.textures.get(t)),e.bind()}unbindTexture(t){let e=this.textures.get(t);e&&e.unbind()}createShader(t,e,n){return new A(this.gl,t,e,n)}drawScene(t,e){return n=this,i=void 0,r=function*(){return new Promise((n=>{const i=()=>{const i=(performance.now()-this.lastFrameAt)/1e3;if(this.drawSync(t,e),this.frame++,W&&this.frame%60==0){const t=(performance.now()-this.frameAverage)/60;this.frameAverage=performance.now();const e=1/(t/1e3)|0;this.debugEl.innerHTML=`${e} fps`}n(i)};e?(this.drawSync(t,e),n(0)):this.vsync?window.requestAnimationFrame(i):setTimeout(i,0)}))},new((o=void 0)||(o=Promise))((function(t,e){function s(t){try{l(r.next(t))}catch(t){e(t)}}function a(t){try{l(r.throw(t))}catch(t){e(t)}}function l(e){var n;e.done?t(e.value):(n=e.value,n instanceof o?n:new o((function(t){t(n)}))).then(s,a)}l((r=r.apply(n,i||[])).next())}));var n,i,o,r}drawSync(t,e){let n;if(e){if(n=this.renderTargets.get(e),!n){this.uploadTexture(e);const t=this.textures.get(e);n=new N(this.gl,e.size,t),e.attachment===D.DEPTH&&(n.attachment=this.gl.DEPTH_ATTACHMENT),this.renderTargets.set(e,n)}this.updateSize(e.size,e.size),n.bind()}this.backgroundColor=[...t.backgroundColor];const i=performance.now();this.lastFrameAt=i,this.gl.viewport(0,0,this.camera.width,this.camera.height),this.clear();const o=this.camera.projection.clone(),r=this.camera.view.inverse(),s=o.multiply(r),a=new Map;for(const e of t.actors){const t=e.shader;t&&(a.get(t)||a.set(t,[]),a.get(t).push(e))}for(const e of a.keys()){e.compiled||e.make(this.gl),e.use(),e.setUniform("uView",r),e.setUniform("uFogColor",this.backgroundColor),e.setUniform("uLineWidth",this.lineWidth),e.setUniform("uTime",performance.now()),e.setUniform("uResolution",[this.camera.width,this.camera.height]),e.setUniform("uSeed",this.seed);for(const n in t.uniforms)e.setUniform(n,t.uniforms[n]);const n=t.lights.length;e.setUniform("uLightCount",n);for(let i=0;i<n;i++){const n=t.lights[i].position,o=t.lights[i].getComponentsOfType(G)[0];e.setUniform(`uLights[${i}].position`,n),e.setUniform(`uLights[${i}].diffuse`,o.diffuse),e.setUniform(`uLights[${i}].ambient`,o.ambient)}for(const t of a.get(e))this.drawActorWithShader(e,t,s)}e&&(n.unbind(),e.attachment!=D.DEPTH&&this.updateSize())}updateSize(t,e){if(!this.parentElement)return;const n=this.parentElement.clientWidth*this.scale|0,i=this.parentElement.clientHeight*this.scale|0;t=null!=t?t:n,e=null!=e?e:i,this.camera.resize(t,e),this.canvas.style.imageRendering="crisp-edges",this.canvas.style.imageRendering="pixelated",this.canvas.style.width=this.parentElement.clientWidth+"px",this.canvas.style.height=this.parentElement.clientHeight+"px",this.canvas.setAttribute("width",n.toString()),this.canvas.setAttribute("height",i.toString())}addEventListener(t,e,n){this.canvas&&this.canvas.addEventListener(t,e,n)}removeEventListener(t,e,n){this.canvas&&this.canvas.removeEventListener(t,e,n)}attach(t=null){var e;null==t||t.appendChild(this.canvas),window.addEventListener("resize",this.updateSize.bind(this,null,null)),this.updateSize(),this.initWebGL(),this.addEventListeners(),W&&(this.debugEl=document.createElement("div"),null===(e=this.canvas.parentElement)||void 0===e||e.appendChild(this.debugEl),Object.assign(this.debugEl.style,{position:"fixed",borderRadius:"12px",zIndex:10,right:"10px",top:"10px",color:"red",fontSize:"32px",background:"rgba(0, 0, 0, 0.5)",padding:"10px"}))}}class z{constructor(t){this.actors=[],this.textures=new Map,this.backgroundColor=[0,0,0,1],this.lights=[],this.uniforms={uShadowMap:null,uLight:null,uLightDir:null},this.renderer=t}addActor(t){const{children:e}=t,n=t=>{var e,n,i,o;t.hasComponentOfType(G)&&this.lights.push(t);for(const e of t.getComponentsOfType(L))this.renderer.uploadMesh(e.mesh);(null===(e=t.material)||void 0===e?void 0:e.texture)&&this.addTexture(t.material.texture),(null===(n=t.material)||void 0===n?void 0:n.normalMap)&&this.addTexture(t.material.normalMap),(null===(i=t.material)||void 0===i?void 0:i.specularMap)&&this.addTexture(t.material.specularMap),(null===(o=t.material)||void 0===o?void 0:o.displacementMap)&&this.addTexture(t.material.displacementMap),this.uploadActorInstances(t)};n(t);for(const t of e)n(t);return this.actors.push(t),this.actors.length-1}uploadActorInstances(t){const{hasInstances:e}=t;if(!e)return;const n=Array.from(t.instances.values()).map((t=>t.data));for(const e of t.getComponentsOfType(L))this.renderer.uploadMeshInstances(e.mesh,n)}addTexture(t){const e=this.renderer.uploadTexture(t);return this.textures.set(e,t),e}getIdOfTexture(t){for(let[e,n]of this.textures.entries())if(n===t)return e;return null}updateTexture(t){if("number"==typeof t){const e=this.textures.get(t);if(!e)throw`Unable to find texture ${t}`;this.renderer.uploadTexture(e,t)}else{const e=this.getIdOfTexture(t);if(null==e)throw"Attempted to upload an unknown texture";this.renderer.uploadTexture(t,e)}}bindTexture(t){const e="number"==typeof t?this.textures.get(t):t;if(!e)throw"Unable to find texture";return this.renderer.bindTexture(e)}unbindTexture(t){const e="number"==typeof t?this.textures.get(t):t;if(!e)throw"Unable to find texture";this.renderer.unbindTexture(e)}draw(){return t=this,e=void 0,i=function*(){return this.castShadows&&this.updateShadowMap(),this.updateLightView(),yield this.renderer.drawScene(this)},new((n=void 0)||(n=Promise))((function(o,r){function s(t){try{l(i.next(t))}catch(t){r(t)}}function a(t){try{l(i.throw(t))}catch(t){r(t)}}function l(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,a)}l((i=i.apply(t,e||[])).next())}));var t,e,n,i}createShadowMap(){if(!this.renderer.gl.getExtension("WEBGL_depth_texture"))throw"WEBGL_depth_texture extension is not supported";this.shadowMap=new I(1024,D.DEPTH)}updateShadowMap(){if(!this.light)return;this.shadowMap||this.createShadowMap();const t=[];for(const e of this.actors)e.visible&&e.material&&!e.material.castsShadows&&(e.visible=!1,t.push(e));this.disableShadows();const e=this.renderer.camera;this.renderer.camera=this.light,this.renderer.drawScene(this,this.shadowMap),this.renderer.camera=e,this.enableShadows();for(const e of t)e.visible=!0}updateLightView(){if(!this.light)return;const t=this.light.projection.clone(),e=this.light.view.inverse(),n=t.multiply(e),i=this.light.view.multiplyVector4([0,0,1,0]),o=f([i[0],i[1],i[2]]);this.uniforms.uLightDir=o,this.uniforms.uLight=n}enableShadows(){this.uniforms.uShadowMap=this.bindTexture(this.shadowMap)}disableShadows(){this.unbindTexture(this.shadowMap),this.uniforms.uShadowMap=null}}class V extends P{constructor(){super(...arguments),this.color=[1,1,1,1],this.castsShadows=!1}}class B extends A{make(t,e,n){const i={uLightCount:{type:WebGLRenderingContext.INT}};for(let t=0;t<8;t++){const e=`uLights[${t}]`;i[`${e}.position`]={type:WebGLRenderingContext.FLOAT_VEC3},i[`${e}.ambient`]={type:WebGLRenderingContext.FLOAT_VEC3},i[`${e}.diffuse`]={type:WebGLRenderingContext.FLOAT_VEC3},i[`${e}.specular`]={type:WebGLRenderingContext.FLOAT_VEC3},i[`${e}.constant`]={type:WebGLRenderingContext.FLOAT},i[`${e}.linear`]={type:WebGLRenderingContext.FLOAT},i[`${e}.quadratic`]={type:WebGLRenderingContext.FLOAT}}super.make(t,e||"#define GLSLIFY 1\nuniform mat4 uViewProj;\nuniform mat4 uView;\nuniform mat4 uModel;\nuniform mat4 uLight;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec4 vPosition;\nvarying vec3 vBasePosition;\nvarying vec2 vTexCoord;\nvarying vec4 vPositionInLight;\n\nvoid main(void) {\n\tmat4 mvp = uModel  * uViewProj;\n\tgl_Position = vec4(position, 1.0) * mvp;\n\tvBasePosition = position;\n\tvPosition = vec4(position, 1.0) * uModel;\n\t//vNormal = normalize((vec4(normal, 0.0) * uModel)).xyz;\n\tvNormal = normal;\n\tvViewNormal = normalize((vec4(normal, 0.0) * uModel * uView)).xyz;\n\tvPositionInLight = vec4(position, 1.0) * uModel * uLight;\n\tvTexCoord = uv;\n}\n",n||"precision highp float;\n#define GLSLIFY 1\n\nstruct Material {\n\tbool castsShadows;\n\tbool receivesShadows;\n\tbool hasTexture;\n\tbool hasNormalMap;\n\tbool hasSpecularMap;\n\tbool hasDisplacementMap;\n\tbool emissive;\n\tvec4 color;\n\tfloat displacementMultiplier;\n\tsampler2D texture;\n\tsampler2D normalMap;\n\tsampler2D specularMap;\n\tsampler2D displacementMap;\n};\n\nstruct Light {\n\tvec3 position;\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\n\tfloat constant;\n\tfloat linear;\n\tfloat quadratic;\n};\n\nuniform mat4 uModel;\nuniform vec4 uFillColor;\nuniform mat4 uView;\nuniform sampler2D uShadowMap;\nuniform vec3 uLightDir;\nuniform Material uMaterial;\nuniform int uLightCount;\nuniform Light uLights[32];\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec4 vPosition;\nvarying vec2 vTexCoord;\nvarying vec4 vPositionInLight;\n\nvoid main(void) {\n\tvec3 texNormal;\n\tif (uMaterial.hasNormalMap) {\n\t\ttexNormal = normalize(vec4(normalize(vNormal) * texture2D(uMaterial.normalMap, vTexCoord).rgb, 0.0) * uModel * uView).xyz;\n\t}\n\telse {\n\t\ttexNormal = normalize(vec4(normalize(vNormal), 0.0) * uModel * uView).xyz;\n\t}\n\tvec4 texColor;\n\tif (uMaterial.hasTexture) {\n\t\ttexColor = texture2D(uMaterial.texture, vTexCoord);\n\t} else {\n\t\ttexColor = uMaterial.color;\n\t}\n\tfloat texSpecular = 0.0;\n\tif (uMaterial.hasSpecularMap) {\n\t\ttexSpecular = texture2D(uMaterial.specularMap, vTexCoord).r;\n\t}\n\n\tif (uMaterial.emissive) {\n\t\tgl_FragColor = texColor;\n\t\treturn;\n\t}\n\n\tvec4 vertPos4 = vPosition * uView;\n\tvec3 vertPos = vertPos4.xyz / vertPos4.w;\n\n\tvec3 ambient = vec3(0.0);\n\tvec3 diffuse = vec3(0.0);\n\tvec3 specular = vec3(0.0);\n\n\tfor (int i = 0; i < 32; i++) {\n\t\tif (i >= uLightCount) break;\n\n\t\tvec4 lightPos4 = vec4(uLights[i].position, 1.0) * uView;\n\t\tvec3 lightPos = lightPos4.xyz / lightPos4.w;\n\n\t\tvec3 lightDir = normalize(lightPos - vertPos);\n\t\tvec3 lightColor = uLights[i].diffuse;\n\t\tambient += uLights[i].ambient;\n\n\t\tfloat diff = max(dot(texNormal, lightDir), 0.0);\n\t\tdiffuse += diff * lightColor;\n\n\t\tfloat lambertian = max(dot(texNormal, lightDir), 0.0);\n\t\tfloat spec = 0.0;\n\n\t\tif (lambertian > 0.0) {\n\t\t\tvec3 reflectDir = reflect(-lightDir, texNormal);\n\t\t\tvec3 viewDir = normalize(-vertPos);\n\n\t\t\tfloat specAngle = max(dot(reflectDir, viewDir), 0.0);\n\t\t\tspec = pow(specAngle, 64.0) * texSpecular;\n\t\t}\n\t\tspecular += spec * lightColor;\n\t}\n\n\tfloat shade = 0.0;\n\n\tif (uMaterial.receivesShadows) {\n\t\tfloat edge = 1.0/1024.0;\n\t\tvec3 shadowPos = (vPositionInLight.xyz / vPositionInLight.w) * 0.5 + 0.5;\n\n\t\tfloat shadows[9];\n\n\t\tshadows[0] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y)).r;\n\t\tshadows[1] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y)).r;\n\t\tshadows[2] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y)).r;\n\t\tshadows[3] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y - edge)).r;\n\t\tshadows[4] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y + edge)).r;\n\t\tshadows[5] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y - edge)).r;\n\t\tshadows[6] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y - edge)).r;\n\t\tshadows[7] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y + edge)).r;\n\t\tshadows[8] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y + edge)).r;\n\n\t\tfloat distanceFromLight = shadowPos.z;\n\n\t\tfloat bias = 0.00001;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (distanceFromLight > shadows[i] + bias) {\n\t\t\t\tshade += 0.08;\n\t\t\t}\n\t\t}\n\t}\n\tvec3 shadowColor = vec3(0.0);\n\n\tvec3 color = mix(texColor.rgb, shadowColor, shade);\n\tcolor = (ambient + diffuse + specular) * color;\n\tgl_FragColor = vec4(color, texColor.a);\n}\n",{attributes:{color:{type:WebGLRenderingContext.FLOAT,size:4},normal:{type:WebGLRenderingContext.FLOAT,size:3},uv:{type:WebGLRenderingContext.FLOAT,size:2}},uniforms:Object.assign(Object.assign({},i),{"uMaterial.color":{type:WebGLRenderingContext.FLOAT_VEC4},"uMaterial.castsShadows":{type:WebGLRenderingContext.BOOL},"uMaterial.receivesShadows":{type:WebGLRenderingContext.BOOL},"uMaterial.displacementMultiplier":{type:WebGLRenderingContext.FLOAT},"uMaterial.hasTexture":{type:WebGLRenderingContext.BOOL},"uMaterial.hasNormalMap":{type:WebGLRenderingContext.BOOL},"uMaterial.hasSpecularMap":{type:WebGLRenderingContext.BOOL},"uMaterial.hasDisplacementMap":{type:WebGLRenderingContext.BOOL},"uMaterial.texture":{type:WebGLRenderingContext.INT},"uMaterial.normalMap":{type:WebGLRenderingContext.INT},"uMaterial.specularMap":{type:WebGLRenderingContext.INT},"uMaterial.displacementMap":{type:WebGLRenderingContext.INT},"uMaterial.emissive":{type:WebGLRenderingContext.BOOL},uTexture:{type:WebGLRenderingContext.INT},uNormalMap:{type:WebGLRenderingContext.INT},uLight:{type:WebGLRenderingContext.FLOAT_MAT4},uLightDir:{type:WebGLRenderingContext.FLOAT_VEC3},uShadowMap:{type:WebGLRenderingContext.INT}})})}}class k extends B{make(t){super.make(t,"#define GLSLIFY 1\nstruct Material {\n\tbool castsShadows;\n\tbool receivesShadows;\n\tbool hasTexture;\n\tbool hasNormalMap;\n\tbool hasSpecularMap;\n\tbool hasDisplacementMap;\n\tbool emissive;\n\tvec4 color;\n\tfloat displacementMultiplier;\n\tsampler2D texture;\n\tsampler2D normalMap;\n\tsampler2D specularMap;\n\tsampler2D displacementMap;\n};\n\n#define PI 3.1415926535897932384626433832795\n\nuniform mat4 uViewProj;\nuniform mat4 uView;\nuniform mat4 uModel;\nuniform mat4 uLight;\nuniform Material uMaterial;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec4 vPosition;\nvarying vec3 vBasePosition;\nvarying vec2 vTexCoord;\nvarying vec4 vPositionInLight;\n\nvec2 toLonLat(vec3 point) {\n\tvec3 v = normalize(point);\n\tfloat lat = acos(v.y) - PI / 2.0;\n\tfloat lon = atan(v.z, v.x) + PI / 2.0;\n\treturn vec2(lon, lat);\n}\n\nvec2 lonLatToUV(vec2 ll) {\n\tfloat x = -ll.x / PI / 2.0;\n\tfloat y = ll.y / PI + 0.5;\n\treturn vec2(fract(x), fract(y));\n}\n\nvoid main(void) {\n\tmat4 mvp = uModel  * uViewProj;\n\tvec2 uv = lonLatToUV(toLonLat(position));\n\tvec3 pos = position;\n\tif (uMaterial.hasDisplacementMap) {\n\t\tvec3 texNormal = texture2D(uMaterial.displacementMap, uv).rgb;\n\t\tpos += normal * texNormal * uMaterial.displacementMultiplier;\n\t}\n\tgl_Position = vec4(pos, 1.0) * mvp;\n\tvBasePosition = pos;\n\tvPosition = vec4(pos, 1.0) * uModel;\n\t//vNormal = normalize((vec4(normal, 0.0) * uModel)).xyz;\n\tvNormal = normal;\n\tvViewNormal = normalize((vec4(normal, 0.0) * uModel * uView)).xyz;\n\tvPositionInLight = vec4(pos, 1.0) * uModel * uLight;\n\tvTexCoord = uv;\n}\n","precision highp float;\n#define GLSLIFY 1\n\nstruct Material {\n\tbool castsShadows;\n\tbool receivesShadows;\n\tbool hasTexture;\n\tbool hasNormalMap;\n\tbool hasSpecularMap;\n\tbool hasDisplacementMap;\n\tbool emissive;\n\tvec4 color;\n\tfloat displacementMultiplier;\n\tsampler2D texture;\n\tsampler2D normalMap;\n\tsampler2D specularMap;\n\tsampler2D displacementMap;\n};\n\nstruct Light {\n\tvec3 position;\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\n\tfloat constant;\n\tfloat linear;\n\tfloat quadratic;\n};\n\nuniform mat4 uModel;\nuniform vec4 uFillColor;\nuniform mat4 uView;\nuniform sampler2D uShadowMap;\nuniform vec3 uLightDir;\nuniform Material uMaterial;\nuniform int uLightCount;\nuniform Light uLights[32];\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec4 vPosition;\nvarying vec2 vTexCoord;\nvarying vec4 vPositionInLight;\nvarying vec3 vBasePosition;\n\n#define PI 3.1415926535897932384626433832795\n\nvec2 toLonLat(vec3 point) {\n\tvec3 v = normalize(point);\n\tfloat lat = acos(v.y) - PI / 2.0;\n\tfloat lon = atan(v.z, v.x) + PI / 2.0;\n\treturn vec2(lon, lat);\n}\n\nvec2 lonLatToUV(vec2 ll) {\n\tfloat x = -ll.x / PI / 2.0;\n\tfloat y = ll.y / PI + 0.5;\n\treturn vec2(fract(x), fract(y));\n}\n\nvoid main(void) {\n\tvec2 uv = lonLatToUV(toLonLat(vBasePosition));\n\n\tvec4 texColor;\n\tif (uMaterial.hasTexture) {\n\t\ttexColor = texture2D(uMaterial.texture, uv);\n\t} else {\n\t\ttexColor = uMaterial.color;\n\t}\n\n\tvec3 texNormal;\n\tif (uMaterial.hasNormalMap) {\n\t\ttexNormal = normalize(vec4(normalize(vNormal) * texture2D(uMaterial.normalMap, uv).rgb, 0.0) * uModel * uView).xyz;\n\t}\n\telse {\n\t\ttexNormal = normalize(vec4(normalize(vNormal), 0.0) * uModel * uView).xyz;\n\t}\n\n\tfloat texSpecular = 0.0;\n\tif (uMaterial.hasSpecularMap) {\n\t\ttexSpecular = texture2D(uMaterial.specularMap, uv).r;\n\t}\n\n\tif (uMaterial.emissive) {\n\t\tgl_FragColor = texColor;\n\t\treturn;\n\t}\n\n\tvec4 vertPos4 = vPosition * uView;\n\tvec3 vertPos = vertPos4.xyz / vertPos4.w;\n\n\tvec3 ambient = vec3(0.0);\n\tvec3 diffuse = vec3(0.0);\n\tvec3 specular = vec3(0.0);\n\n\tfor (int i = 0; i < 32; i++) {\n\t\tif (i >= uLightCount) break;\n\n\t\tvec4 lightPos4 = vec4(uLights[i].position, 1.0) * uView;\n\t\tvec3 lightPos = lightPos4.xyz / lightPos4.w;\n\n\t\tvec3 lightDir = normalize(lightPos - vertPos);\n\t\tvec3 lightColor = uLights[i].diffuse;\n\t\tambient += uLights[i].ambient;\n\n\t\tfloat diff = max(dot(texNormal, lightDir), 0.0);\n\t\tdiffuse += diff * lightColor;\n\n\t\tfloat lambertian = max(dot(texNormal, lightDir), 0.0);\n\t\tfloat spec = 0.0;\n\n\t\tif (lambertian > 0.0) {\n\t\t\tvec3 reflectDir = reflect(-lightDir, texNormal);\n\t\t\tvec3 viewDir = normalize(-vertPos);\n\n\t\t\tfloat specAngle = max(dot(reflectDir, viewDir), 0.0);\n\t\t\tspec = pow(specAngle, 64.0) * texSpecular;\n\t\t}\n\t\tspecular += spec * lightColor;\n\t}\n\n\tfloat shade = 0.0;\n\n\tif (uMaterial.receivesShadows) {\n\t\tfloat edge = 1.0/1024.0;\n\t\tvec3 shadowPos = (vPositionInLight.xyz / vPositionInLight.w) * 0.5 + 0.5;\n\n\t\tfloat shadows[9];\n\n\t\tshadows[0] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y)).r;\n\t\tshadows[1] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y)).r;\n\t\tshadows[2] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y)).r;\n\t\tshadows[3] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y - edge)).r;\n\t\tshadows[4] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y + edge)).r;\n\t\tshadows[5] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y - edge)).r;\n\t\tshadows[6] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y - edge)).r;\n\t\tshadows[7] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y + edge)).r;\n\t\tshadows[8] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y + edge)).r;\n\n\t\tfloat distanceFromLight = shadowPos.z;\n\n\t\tfloat bias = 0.00001;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (distanceFromLight > shadows[i] + bias) {\n\t\t\t\tshade += 0.08;\n\t\t\t}\n\t\t}\n\t}\n\tvec3 shadowColor = vec3(0.0);\n\n\tvec3 color = mix(texColor.rgb, shadowColor, shade);\n\tcolor = (ambient + diffuse + specular) * color;\n\tgl_FragColor = vec4(color, texColor.a);\n}\n")}}class j extends A{make(t){super.make(t,"#define GLSLIFY 1\nuniform mat4 uViewProj;\nuniform mat4 uModel;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n\tmat4 mvp = uModel * uViewProj;\n\tgl_Position = vec4(position, 1.0) * mvp;\n\tvTexCoord = vec2(uv.x, 1.0 - uv.y);\n}\n\n","precision mediump float;\n#define GLSLIFY 1\n\nuniform float uTime;\nuniform sampler2D uSampler;\nuniform float uContrast;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n\tfloat contrast = uContrast > 0.0 ? uContrast : 1.0;\n\tgl_FragColor = (texture2D(uSampler, vTexCoord) - (1.0 - (1.0 / contrast))) * contrast;\n}\n",{attributes:{uv:{type:WebGLRenderingContext.FLOAT,size:2}},uniforms:{uSampler:{type:WebGLRenderingContext.INT},uContrast:{type:WebGLRenderingContext.FLOAT}}})}}class H extends A{make(t){super.make(t,"#define GLSLIFY 1\nuniform mat4 uViewProj;\nuniform mat4 uView;\nuniform mat4 uModel;\nuniform mat4 uLight;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec2 uv;\n\nvarying vec4 vColor;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec4 vPositionInLight;\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n\tmat4 mvp = uModel  * uViewProj;\n\tgl_Position = vec4(position, 1.0) * mvp;\n\tvColor = color;\n\tvPosition = (vec4(position, 1.0) * uModel * uView).xyz;\n\tvPositionInLight = vec4(position, 1.0) * uModel * uLight;\n\tvNormal = normalize((vec4(normal, 0.0) * uModel)).xyz;\n\tvTexCoord = uv;\n}\n","precision mediump float;\n#define GLSLIFY 1\n\nuniform float uTime;\nuniform vec4 uFillColor;\nuniform sampler2D uShadowMap;\nuniform vec3 uLightDir;\n\nvarying vec4 vColor;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec4 vPositionInLight;\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n\tvec3 lightColor = vec3(1.0);\n\tvec3 ambient = 0.1 * lightColor;\n\n\tfloat diff = max(dot(vNormal, uLightDir), 0.0);\n\tvec3 diffuse = diff * lightColor;\n\n\tvec3 viewDir = normalize(-vPosition);\n\tvec3 reflectDir = reflect(-uLightDir, vNormal);\n\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 128.0);\n\tvec3 specular = 0.5 * spec * lightColor;\n\n\tvec3 color = (ambient + diffuse + specular) * vColor.rgb;\n\n\tif (uFillColor.a > 0.0) {\n\t\tfloat shade = 0.0;\n\n\t\tfloat edge = 1.0/1024.0;\n\t\tvec3 shadowPos = (vPositionInLight.xyz / vPositionInLight.w) * 0.5 + 0.5;\n\n\t\tfloat shadows[9];\n\n\t\tshadows[0] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y)).r;\n\t\tshadows[1] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y)).r;\n\t\tshadows[2] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y)).r;\n\t\tshadows[3] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y - edge)).r;\n\t\tshadows[4] = texture2D(uShadowMap, vec2(shadowPos.x, shadowPos.y + edge)).r;\n\t\tshadows[5] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y - edge)).r;\n\t\tshadows[6] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y - edge)).r;\n\t\tshadows[7] = texture2D(uShadowMap, vec2(shadowPos.x - edge, shadowPos.y + edge)).r;\n\t\tshadows[8] = texture2D(uShadowMap, vec2(shadowPos.x + edge, shadowPos.y + edge)).r;\n\n\t\tfloat distanceFromLight = shadowPos.z;\n\n\t\tfloat bias = 0.0001;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (distanceFromLight > shadows[i] + bias) {\n\t\t\t\tshade += 0.08;\n\t\t\t}\n\t\t}\n\t\tvec3 shadowColor = vec3(0.0);\n\t\tgl_FragColor = vec4(mix(uFillColor.rgb, shadowColor, shade), vColor.a);\n\t} else {\n\t\tgl_FragColor = vec4(color, vColor.a);\n\t}\n}\n",{attributes:{color:{type:WebGLRenderingContext.FLOAT,size:4},normal:{type:WebGLRenderingContext.FLOAT,size:3},uv:{type:WebGLRenderingContext.FLOAT,size:2}},uniforms:{uLight:{type:WebGLRenderingContext.FLOAT_MAT4},uLightDir:{type:WebGLRenderingContext.FLOAT_VEC3},uShadowMap:{type:WebGLRenderingContext.INT}}})}}class X extends b{constructor(t,e){let{vertices:i,normals:o,uvs:r}=function(t){const e=[],n=[],i=[],o=[];for(const r of t.split("\n"))switch(r.split(" ")[0]){case"v":e.push($(r));break;case"f":n.push(q(r));break;case"vt":o.push(K(r));break;case"vn":i.push(Y(r))}return{vertices:n.flat().map((t=>e[t[0]])),normals:n.flat().map((t=>i[t[2]])),uvs:n.flat().map((t=>o[t[1]]))}}(t);if(null==e?void 0:e.scale){const t=n.scaling(e.scale,e.scale,e.scale);i=i.map((e=>t.transformPoint3(e)))}if(null==e?void 0:e.flipFaces)for(let t=0;t<i.length;t+=3){const e=i[t],n=i[t+2];i[t]=n,i[t+2]=e}super(i.map(((t,e)=>({position:t,normal:o[e],uv:r[e]}))))}static fromUrl(t){return e=this,n=void 0,o=function*(){const e=yield fetch(t),n=yield e.text();return new X(n)},new((i=void 0)||(i=Promise))((function(t,r){function s(t){try{l(o.next(t))}catch(t){r(t)}}function a(t){try{l(o.throw(t))}catch(t){r(t)}}function l(e){var n;e.done?t(e.value):(n=e.value,n instanceof i?n:new i((function(t){t(n)}))).then(s,a)}l((o=o.apply(e,n||[])).next())}));var e,n,i,o}}function $(t){return t.split(" ").filter((t=>t)).slice(1).map(parseFloat)}function Y(t){return t.split(" ").filter((t=>t)).slice(1).map(parseFloat)}function K(t){const e=t.split(" ").filter((t=>t)).slice(1).map((t=>parseFloat(t)));return[e[0],1-e[1]]}function q(t){return t.split(" ").filter((t=>t)).slice(1).map((t=>t.split("/").map((t=>parseInt(t,10)-1))))}class Q extends b{constructor(){const t=new Array(J.length/3);for(let e=0;e<t.length;e++){const n=[J[3*e+0],J[3*e+1],J[3*e+2]],i=[Z[(2*e+0)%Z.length],Z[(2*e+1)%Z.length]],o=[0,0,0];t[e]={position:n,uv:i,normal:o,color:[0,1,0,1]}}super(t),this.calculateNormals()}}const Z=[1,0,0,0,1,1,0,1,1,1,0,0],J=[-1,1,-1,1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1];class tt extends b{constructor(t,e){const n=new Array(t*e*6);let i=0;for(let s=-.5*e;s<.5*e;s++){const a=Math.PI*(s/e),l=Math.PI*((s+1)/e);for(let e=-.5*t;e<.5*t;e++){const s=2*Math.PI*(e/t),u=2*Math.PI*((e+1)/t),c=[[u,l],[s,l],[s,a],[u,a],[u,l],[s,a]];for(const t of c){const e=(o=t[0],r=t[1],[Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)]),s={position:e,normal:f(e),uv:it(t[0],t[1]),color:[1,0,0,1]};n[i++]=s}}}var o,r;super(n)}}class et extends b{constructor(t){super([new nt(t,[0,1,0]),new nt(t,[0,-1,0]),new nt(t,[1,0,0]),new nt(t,[-1,0,0]),new nt(t,[0,0,1]),new nt(t,[0,0,-1])])}}class nt extends x{constructor(t,e){const n=new Array(t*t),i=[e[1],e[2],e[0]],o=d(e,i),r=new Array(t*t),s=new Array((t-1)*(t-1));let a=0;const u=1/(t-1);for(let n=0;n<t;n++)for(let h=0;h<t;h++){const d=[h*u,n*u],m=[2*(d[0]-.5),2*(d[1]-.5)];let p=e;p=l(p,c([m[0],m[0],m[0]],i)),p=l(p,c([m[1],m[1],m[1]],o)),p=f(p);const v={position:p,normal:p,uv:[0,0],color:[1,0,0,1]},g=h+n*t;r[g]=v,h<t-1&&n<t-1&&(s[a++]=g,s[a++]=g+t+1,s[a++]=g+t,s[a++]=g,s[a++]=g+1,s[a++]=g+t+1)}for(let t=0;t<s.length;t++)n[t]=r[s[t]];super(n)}}function it(t,e){return[t/Math.PI/2+.5,-e/Math.PI+.5]}class ot extends b{constructor(){super([{position:[1,1,0],uv:[1,0],color:[0,0,0,1],normal:[0,0,1]},{position:[-1,1,0],uv:[0,0],color:[0,0,0,1],normal:[0,0,1]},{position:[1,-1,0],uv:[1,1],color:[0,0,0,1],normal:[0,0,1]},{position:[-1,-1,0],uv:[0,1],color:[0,0,0,1],normal:[0,0,1]},{position:[1,-1,0],uv:[1,1],color:[0,0,0,1],normal:[0,0,1]},{position:[-1,1,0],uv:[0,0],color:[0,0,0,1],normal:[0,0,1]}]),this.calculateNormals()}}return e})()}));
//# sourceMappingURL=index.js.map